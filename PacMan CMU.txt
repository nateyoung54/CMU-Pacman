<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chip Chase — CMU One-Level</title>
  <style>
    :root { --maroon:#6a0032; --gold:#ffcc33; --bg:#0f1115; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 70% -10%, #172031 0%, #0f1115 60%, #0b0d12 100%);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#e8eaed}
    .wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}
    header{display:flex;align-items:center;justify-content:space-between;padding:16px 20px}
    .brand{display:flex;gap:12px;align-items:center}
    .badge{width:14px;height:14px;border-radius:3px;background:linear-gradient(140deg,var(--maroon),#3b001c)}
    .brand h1{margin:0;font-size:18px;letter-spacing:.5px;font-weight:700}
    .brand h1 span{color:var(--gold)}
    .hud{display:flex;gap:12px;align-items:center}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border-radius:999px;background:#131722;border:1px solid #242a3b;font-size:12px}
    .key{width:18px;height:18px;border-radius:4px;display:inline-grid;place-items:center;background:#0e1220;border:1px solid #293149;color:#cbd5e1;font-weight:700;font-size:11px}
    main{display:grid;place-items:center;padding:8px 16px 24px}
    .stage{position:relative;display:grid;grid-template-columns:1fr;gap:12px}
    canvas{width:min(90vw,920px);height:calc(min(90vw,920px)*0.75);max-width:920px;background:#0b0f1a;border-radius:20px;border:1px solid #20283a;box-shadow:0 10px 30px #0008,inset 0 0 0 1px #fff1;image-rendering:pixelated}
    .panel{display:flex;gap:12px;justify-content:space-between;align-items:center;padding:10px 12px;background:#111624;border:1px solid #27304a;border-radius:14px}
    .stats{display:flex;gap:12px}
    .stat{background:#0d1220;border:1px solid #242c44;padding:8px 10px;border-radius:10px;min-width:88px;text-align:center}
    .stat .label{color:#8a93a8;font-size:11px;letter-spacing:.3px}
    .stat .val{color:#eaeefb;font-weight:700;font-size:16px}
    button{appearance:none;border:0;padding:10px 14px;border-radius:12px;background:linear-gradient(180deg,#1c2134,#111628);color:#eaeefb;border:1px solid #27304a;font-weight:600;cursor:pointer}
    .primary{background:linear-gradient(180deg,var(--gold),#d6ac1d);color:#1a1300;border-color:#e2b61a}
    .toast{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
    .card{pointer-events:auto;background:linear-gradient(180deg,#101624,#0c1120);border:1px solid #27304a;box-shadow:0 20px 50px #000a;padding:20px;border-radius:16px;text-align:center;max-width:420px}
    .title{font-weight:800;font-size:22px;margin:6px 0 12px}
    .subtitle{color:#9aa6bf;font-size:13px;margin:0 0 14px}
    footer{padding:10px 16px 16px;color:#6b7280;font-size:12px;text-align:center}
    .cmu{color:var(--gold)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand"><div class="badge"></div><h1>Chip <span>Chase</span></h1></div>
      <div class="hud">
        <div class="pill"><div class="key">↑</div><div class="key">↓</div><div class="key">←</div><div class="key">→</div> Move</div>
        <div class="pill">No sound • Single player • One level</div>
      </div>
    </header>

    <main>
      <div class="stage">
        <canvas id="game" width="736" height="552" aria-label="Chip Chase game area" role="img"></canvas>
        <div class="panel">
          <div class="stats">
            <div class="stat"><div class="label">Score</div><div class="val" id="score">0</div></div>
            <div class="stat"><div class="label">Pellets</div><div class="val" id="pellets">0</div></div>
            <div class="stat"><div class="label">Lives</div><div class="val" id="lives">3</div></div>
          </div>
          <div>
            <button id="btnPause">Pause</button>
            <button id="btnReset" class="primary">Reset</button>
          </div>
        </div>
        <div class="toast" id="overlay">
          <div class="card">
            <div class="title" id="overlayTitle">Chip Chase</div>
            <div class="subtitle" id="overlaySub">Collect all maroon pellets. Avoid rivals. Arrows to move.</div>
            <button id="btnStart" class="primary">Start</button>
          </div>
        </div>
      </div>
    </main>

    <footer>
      CMU theme: <span class="cmu">Maroon & Gold</span>. Modern single-level maze. Optimized for desktop and arrows.
    </footer>
  </div>

  <script>
    // ===== Config =====
    const TILE=23, GRID_W=32, GRID_H=24; // canvas: 736x552
    const WIDTH=GRID_W*TILE, HEIGHT=GRID_H*TILE;
    const SPEED=2.6, ENEMY_SPEED=2.1; // ghosts slower than player
    const POWER_FRAMES=600; // 10s @ 60fps
    const TILE_EMPTY=0, TILE_WALL=1, TILE_PELLET=2, TILE_POWER=3;

    // Base map strings: 24x32
    const BASE_MAP_STRINGS=[
      "11111111111111111111111111111111",
      "1..............1111.............1",
      "1.111111.11111.1111.11111.11111.1",
      "1.1....1.1...1.....1.1...1.1....11",
      "1.1.11.1.1.1.111111.1.1.1.1.11..1",
      "1...11...1.1.....11...1.1...11..1",
      "111.111111.11111.11111.11111.1..1",
      "1..........1...1.....1.....1.1..1",
      "1.11111.1111.1.11111.1111.1.1..11",
      "1.1...1.1.....1.....1.....1.1...1",
      "1.1.1.1.1.111111111111111.1.1.1.1",
      "1...1...1....1.......1....1...1.1",
      "111.11111111.1.11111.1.1111111.11",
      "1..........1.1.1...1.1.1......1.1",
      "1.11111.1.1.1.1.1.1.1.1.11111.1.1",
      "1.1.....1.1...1.1.1...1.1.....1.1",
      "1.1.11111.11111.1.11111.11111.1.1",
      "1.1.........................1..1.1",
      "1.111111111111.111111111111.11.11",
      "1................1..............11",
      "1.11111.11111111.1.11111111.111.1",
      "1........1....P..1..E....1......11",
      "1111111111111111111111111111111111",
      "1111111111111111111111111111111111"
    ];

    // ===== Map build + guards =====
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

    function normalizeRow(row,w){
      if(row.length===w) return row;
      if(row.length>w) return row.slice(0,w);
      return row+"1".repeat(w-row.length);
    }

    function buildMap(){
      const grid=new Array(GRID_H);
      let playerStart={x:1,y:GRID_H-3}, enemyStart={x:GRID_W-5,y:GRID_H-3};
      let pellets=0;
      for(let y=0;y<GRID_H;y++){
        const row=normalizeRow(BASE_MAP_STRINGS[y]||"".padEnd(GRID_W,"1"),GRID_W);
        const a=new Array(GRID_W);
        for(let x=0;x<GRID_W;x++){
          const c=row[x];
          if(c==='.') {a[x]=TILE_PELLET; pellets++;}
          else if(c==='1'){a[x]=TILE_WALL;}
          else if(c==='P'){playerStart={x,y}; a[x]=TILE_EMPTY;}
          else if(c==='E'){enemyStart={x,y}; a[x]=TILE_EMPTY;}
          else {a[x]=TILE_EMPTY;}
        }
        grid[y]=a;
      }
      return {map:grid, playerStart, enemyStart, pellets};
    }

    let {map:MAP, playerStart, enemyStart, pellets:initialPellets}=buildMap();

    function findOpenNear(tx,ty){
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; let radius=0;
      while(radius<Math.max(GRID_W,GRID_H)){
        for(let d=0; d<dirs.length; d++){
          const x=tx+dirs[d][0]*radius, y=ty+dirs[d][1]*radius;
          if(x>=0&&y>=0&&x<GRID_W&&y<GRID_H && MAP[y][x]!==TILE_WALL) return {x,y};
        }
        radius++;
      }
      return {x:tx,y:ty};
    }
    function randomizePowerPellets(k=4){
      const spots=[]; for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) if(MAP[y][x]===TILE_PELLET) spots.push([x,y]);
      for(let i=0;i<k&&spots.length;i++){ const idx=(Math.random()*spots.length)|0; const [x,y]=spots.splice(idx,1)[0]; MAP[y][x]=TILE_POWER; }
    }

    // ===== Canvas + UI =====
    const cvs=document.getElementById('game');
    const ctx=cvs.getContext('2d');
    const ui={
      score:document.getElementById('score'),
      pellets:document.getElementById('pellets'),
      lives:document.getElementById('lives'),
      overlay:document.getElementById('overlay'),
      overlayTitle:document.getElementById('overlayTitle'),
      overlaySub:document.getElementById('overlaySub'),
      btnStart:document.getElementById('btnStart'),
      btnReset:document.getElementById('btnReset'),
      btnPause:document.getElementById('btnPause')
    };

    // ===== Game State =====
    const state={
      running:false,
      paused:false,
      score:0,
      pelletsLeft:initialPellets,
      lives:3,
      player:{x:playerStart.x*TILE+TILE/2,y:playerStart.y*TILE+TILE/2,vx:0,vy:0,radius:7},
      enemies:[],
      intent:{x:0,y:0},
      phase:{mode:'scatter', timer:180},
      power:0
    };

    // seed enemies
    (function initEnemies(){
      const s1=findOpenNear(enemyStart.x, enemyStart.y);
      const s2=findOpenNear(GRID_W-6, 6);
      const s3=findOpenNear(6, GRID_H-6);
      state.enemies=[
        {name:'Maroon', x:s1.x*TILE+TILE/2, y:s1.y*TILE+TILE/2, vx:0, vy:0, radius:9, color:'#6a0032', prefer:'chase'},
        {name:'Gold',   x:s2.x*TILE+TILE/2, y:s2.y*TILE+TILE/2, vx:0, vy:0, radius:9, color:'#d4a514', prefer:'patrol'},
        {name:'Slate',  x:s3.x*TILE+TILE/2, y:s3.y*TILE+TILE/2, vx:0, vy:0, radius:9, color:'#344561', prefer:'ambush'},
      ];
    })();

    // ===== Helpers =====
    const nearCenter=(n)=>{const g=(n-TILE/2)/TILE; return Math.abs(g-Math.round(g))<0.15};

    function centerAlign(n, axis){
      const limit = (axis==='x') ? GRID_W : GRID_H;
      let idx = Math.floor(n / TILE);
      if (idx < 0) idx = 0; else if (idx > limit - 1) idx = limit - 1;
      return idx * TILE + TILE/2;
    }

    function clampCenter(){
      state.player.x=clamp(state.player.x, TILE/2, WIDTH-TILE/2);
      state.player.y=clamp(state.player.y, TILE/2, HEIGHT-TILE/2);
      for(const g of state.enemies){
        g.x=clamp(g.x, TILE/2, WIDTH-TILE/2);
        g.y=clamp(g.y, TILE/2, HEIGHT-TILE/2);
      }
    }

    function tileAt(px,py){
      const x=Math.floor(px/TILE), y=Math.floor(py/TILE);
      if(x<0||y<0||x>=GRID_W||y>=GRID_H) return TILE_WALL; // treat OOB as wall
      return MAP[y][x];
    }

    function canMove(cx,cy,nx,ny,r){
      const re = Math.max(2, r - 2.5); // softer collision to ease corridors
      const minTX=Math.floor((nx-re)/TILE), maxTX=Math.floor((nx+re)/TILE);
      const minTY=Math.floor((ny-re)/TILE), maxTY=Math.floor((ny+re)/TILE);
      for(let ty=minTY;ty<=maxTY;ty++){
        for(let tx=minTX;tx<=maxTX;tx++){
          if(tx<0||ty<0||tx>=GRID_W||ty>=GRID_H) return false;
          if(MAP[ty][tx]===TILE_WALL) return false;
        }
      }
      return true;
    }

    function vecTowards(ax,ay,bx,by){return {x:Math.sign(bx-ax), y:Math.sign(by-ay)}}
    function countPellets(){let t=0; for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++){ const v=MAP[y][x]; if(v===TILE_PELLET||v===TILE_POWER) t++; } return t;}

    function resetGame(){
      const built=buildMap();
      MAP=built.map; playerStart=built.playerStart; enemyStart=built.enemyStart;
      state.score=0; state.lives=3; state.intent.x=0; state.intent.y=0; state.power=0;
      state.player.x=playerStart.x*TILE+TILE/2; state.player.y=playerStart.y*TILE+TILE/2; state.player.vx=0; state.player.vy=0;
      const s1=findOpenNear(enemyStart.x, enemyStart.y);
      const s2=findOpenNear(GRID_W-6, 6);
      const s3=findOpenNear(6, GRID_H-6);
      state.enemies=[
        {name:'Maroon', x:s1.x*TILE+TILE/2, y:s1.y*TILE+TILE/2, vx:0, vy:0, radius:9, color:'#6a0032', prefer:'chase'},
        {name:'Gold',   x:s2.x*TILE+TILE/2, y:s2.y*TILE+TILE/2, vx:0, vy:0, radius:9, color:'#d4a514', prefer:'patrol'},
        {name:'Slate',  x:s3.x*TILE+TILE/2, y:s3.y*TILE+TILE/2, vx:0, vy:0, radius:9, color:'#344561', prefer:'ambush'},
      ];
      state.phase={mode:'scatter', timer:180};
      state.pelletsLeft=countPellets();
      ui.score.textContent=state.score; ui.lives.textContent=state.lives; ui.pellets.textContent=state.pelletsLeft;
      ui.overlay.hidden=false; ui.overlay.style.display='grid'; ui.overlay.removeAttribute('aria-hidden'); ui.overlayTitle.textContent='Chip Chase'; ui.overlaySub.textContent='Collect all maroon pellets. Avoid the rivals. Arrows to move.';
      state.running=false; state.paused=false;
    }

    // ===== Input =====
    const keyDir={37:{x:-1,y:0},38:{x:0,y:-1},39:{x:1,y:0},40:{x:0,y:1}};
    addEventListener('keydown',(e)=>{
      if(keyDir[e.keyCode]){ e.preventDefault(); const d=keyDir[e.keyCode]; state.intent.x=d.x; state.intent.y=d.y; }
      if(e.key==='p'||e.key==='P'){ e.preventDefault(); togglePause(); }
    });
    ui.btnStart.addEventListener('click',()=>{
      randomizePowerPellets(4); // place power-up pellets each run
      ui.overlay.hidden=true; ui.overlay.style.display='none'; ui.overlay.setAttribute('aria-hidden','true');
      state.power=0; state.running=true;
    });
    ui.btnReset.addEventListener('click',resetGame);
    ui.btnPause.addEventListener('click',togglePause);
    function togglePause(){ if(!state.running) return; state.paused=!state.paused; ui.btnPause.textContent=state.paused?'Resume':'Pause'; }

    // ===== Update =====
    function step(){
      if(!state.running||state.paused) return;

      const pr=state.player.radius; const px=state.player.x, py=state.player.y;
      if(state.intent.x!==0 && nearCenter(py)){
        const nx=px+state.intent.x*SPEED, ny=py;
        if(canMove(px,py,nx,ny,pr)){
          state.player.vx=state.intent.x*SPEED; state.player.vy=0; state.player.y=centerAlign(py,'y');
        }
      } else if(state.intent.y!==0 && nearCenter(px)){
        const nx=px, ny=py+state.intent.y*SPEED;
        if(canMove(px,py,nx,ny,pr)){
          state.player.vy=state.intent.y*SPEED; state.player.vx=0; state.player.x=centerAlign(px,'x');
        }
      }

      // Move player
      let nx=state.player.x+state.player.vx, ny=state.player.y+state.player.vy;
      if(canMove(state.player.x,state.player.y,nx,ny,pr)){
        state.player.x=nx; state.player.y=ny;
      } else {
        state.player.vx=0; state.player.vy=0; state.player.x=centerAlign(state.player.x,'x'); state.player.y=centerAlign(state.player.y,'y');
      }
      // Micro auto-centering while moving to prevent wall snag
      if(state.player.vx!==0) state.player.y=centerAlign(state.player.y,'y');
      if(state.player.vy!==0) state.player.x=centerAlign(state.player.x,'x');
      clampCenter();

      // Pellets / power-ups
      const tx=Math.floor(state.player.x/TILE), ty=Math.floor(state.player.y/TILE);
      if(tx>=0&&ty>=0&&tx<GRID_W&&ty<GRID_H){
        const tile=MAP[ty][tx];
        if(tile===TILE_PELLET||tile===TILE_POWER){
          MAP[ty][tx]=TILE_EMPTY; state.score += (tile===TILE_POWER?50:10); state.pelletsLeft--; ui.score.textContent=state.score; ui.pellets.textContent=state.pelletsLeft;
          if(tile===TILE_POWER) state.power=POWER_FRAMES;
          if(state.pelletsLeft<=0) win();
        }
      }

      // Phase timer toggle
      state.phase.timer--; if(state.phase.timer<=0){
        if(state.phase.mode==='scatter'){ state.phase.mode='chase'; state.phase.timer=420; }
        else { state.phase.mode='scatter'; state.phase.timer=180; }
      }

      // Power countdown
      if(state.power>0) state.power--;

      // Ghosts
      for(const g of state.enemies){
        const er=g.radius; const ex=g.x, ey=g.y;
        const atIntersection=nearCenter(ex)&&nearCenter(ey);
        if(atIntersection){
          const candidates=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].filter(d=>{
            if(g.vx!==0||g.vy!==0){ if(d.x===-Math.sign(g.vx) && d.y===-Math.sign(g.vy)) return false; }
            return canMove(ex,ey,ex+d.x*ENEMY_SPEED*3,ey+d.y*ENEMY_SPEED*3,er);
          });
          let dirs=candidates.length?candidates:[{x:-Math.sign(g.vx),y:-Math.sign(g.vy)}];
          let target;
          if(state.power>0){ target={x: ex+(ex-state.player.x)*4, y: ey+(ey-state.player.y)*4}; }
          else if(state.phase.mode==='scatter'){
            target = g.name==='Maroon'? {x:WIDTH-TILE,y:TILE} : g.name==='Gold'? {x:WIDTH-TILE,y:HEIGHT-TILE} : {x:TILE,y:TILE};
          } else {
            if(g.prefer==='ambush') target={x:state.player.x+state.player.vx*12, y:state.player.y+state.player.vy*12};
            else if(g.prefer==='patrol') target={x:state.player.x, y:state.player.y + 80*Math.sign(state.player.vy||1)};
            else target={x:state.player.x, y:state.player.y};
          }
          dirs.sort((a,b)=>{ const ax=ex+a.x*TILE, ay=ey+a.y*TILE; const bx=ex+b.x*TILE, by=ey+b.y*TILE; const da=(ax-target.x)**2+(ay-target.y)**2; const db=(bx-target.x)**2+(by-target.y)**2; return da-db; });
          const jitter= state.power>0 ? 0.35 : 0.2; const pick = Math.random()<jitter && dirs.length>1 ? dirs[1] : dirs[0];
          const spd= state.power>0 ? ENEMY_SPEED*0.7 : ENEMY_SPEED; g.vx=pick.x*spd; g.vy=pick.y*spd;
        }
        nx=g.x+g.vx; ny=g.y+g.vy;
        if(canMove(g.x,g.y,nx,ny,er)){ g.x=nx; g.y=ny; } else { g.vx=0; g.vy=0; g.x=centerAlign(g.x,'x'); g.y=centerAlign(g.y,'y'); }
      }
      clampCenter();

      // Collisions
      for(let i=state.enemies.length-1;i>=0;i--){
        const g=state.enemies[i];
        const dx=g.x-state.player.x, dy=g.y-state.player.y; const rsum=(g.radius+pr-2);
        if((dx*dx+dy*dy)<(rsum*rsum)){
          if(state.power>0){
            state.score+=200; ui.score.textContent=state.score;
            state.enemies.splice(i,1); // permanent removal until death/reset
            continue;
          } else {
            loseLife();
            break;
          }
        }
      }
    }

    // ===== Win/Lose =====
    function win(){
      state.running=false;
      ui.overlay.hidden=false; ui.overlay.style.display='grid'; ui.overlay.removeAttribute('aria-hidden');
      ui.overlayTitle.textContent='You win';
      ui.overlaySub.textContent=`All pellets collected. Score ${state.score}. Reset to play again.`;
    }

    function loseLife(){
      state.lives--; ui.lives.textContent=state.lives;
      if(state.lives<=0){
        state.running=false;
        ui.overlay.hidden=false; ui.overlay.style.display='grid'; ui.overlay.removeAttribute('aria-hidden');
        ui.overlayTitle.textContent='Game over';
        ui.overlaySub.textContent=`Final score ${state.score}. Reset to try again.`;
        return;
      }
      // reset player
      state.player.x=playerStart.x*TILE+TILE/2; state.player.y=playerStart.y*TILE+TILE/2; state.player.vx=0; state.player.vy=0;
      // respawn ALL ghosts each death
      const s1=findOpenNear(enemyStart.x, enemyStart.y);
      const s2=findOpenNear(GRID_W-6, 6);
      const s3=findOpenNear(6, GRID_H-6);
      state.enemies=[
        {name:'Maroon', x:s1.x*TILE+TILE/2, y:s1.y*TILE+TILE/2, vx:0, vy:0, radius:9, color:'#6a0032', prefer:'chase'},
        {name:'Gold',   x:s2.x*TILE+TILE/2, y:s2.y*TILE+TILE/2, vx:0, vy:0, radius:9, color:'#d4a514', prefer:'patrol'},
        {name:'Slate',  x:s3.x*TILE+TILE/2, y:s3.y*TILE+TILE/2, vx:0, vy:0, radius:9, color:'#344561', prefer:'ambush'},
      ];
    }

    // ===== Render =====
    function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

    function drawCMU(x,y,size){
      const outerR=size, innerR=size*0.55, thickness=outerR-innerR;
      const ang=Math.atan2(state.player.vy,state.player.vx)||0; ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
      ctx.beginPath(); roundRect(ctx,-outerR,-outerR,outerR*2,outerR*2,thickness); ctx.clip();
      ctx.fillStyle='#6a0032'; ctx.fillRect(-outerR-1,-outerR-1,outerR*2+2,outerR*2+2);
      const prev=ctx.globalCompositeOperation; ctx.globalCompositeOperation='destination-out';
      ctx.beginPath(); ctx.arc(0,0,innerR,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.rect(innerR*0.2,-outerR-2,outerR*2,outerR*2+4); ctx.fill();
      ctx.globalCompositeOperation=prev;
      ctx.lineWidth=Math.max(2,thickness*0.55); ctx.strokeStyle='#ffcc33';
      ctx.beginPath(); ctx.arc(0,0,outerR-ctx.lineWidth*0.5,0.35*Math.PI,1.65*Math.PI); ctx.stroke();
      ctx.restore();
    }

    function drawGhost(x,y,r,body){
      const frightened = state.power>0;
      const cBody = frightened ? '#3b82f6' : body;
      ctx.fillStyle=cBody; ctx.beginPath(); ctx.arc(x,y,r,Math.PI,0); ctx.lineTo(x+r,y+r); const base=4; for(let i=0;i<6;i++){ const px=x+r-i*(r*2/6); const py=y+r+(i%2?base:-base); ctx.lineTo(px,py); } ctx.closePath(); ctx.fill();
      ctx.fillStyle='#e6f0ff'; ctx.beginPath(); ctx.arc(x-r*0.35,y-r*0.15,r*0.22,0,Math.PI*2); ctx.arc(x+r*0.15,y-r*0.15,r*0.22,0,Math.PI*2); ctx.fill();
      const dir=vecTowards(x,y,state.player.x,state.player.y); ctx.fillStyle= frightened? '#0f172a' : '#17213a'; ctx.beginPath(); ctx.arc(x-r*0.35+dir.x*2,y-r*0.15+dir.y*2,r*0.10,0,Math.PI*2); ctx.arc(x+r*0.15+dir.x*2,y-r*0.15+dir.y*2,r*0.10,0,Math.PI*2); ctx.fill();
    }

    function render(){
      ctx.clearRect(0,0,cvs.width,cvs.height);
      // BG
      ctx.fillStyle='#0a0e18'; ctx.fillRect(0,0,cvs.width,cvs.height);
      // Walls
      for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) if(MAP[y][x]===TILE_WALL){ ctx.fillStyle='#1b2436'; const rx=x*TILE, ry=y*TILE; roundRect(ctx,rx+2,ry+2,TILE-4,TILE-4,6); ctx.fill(); ctx.strokeStyle='#2a3550'; ctx.lineWidth=1; ctx.stroke(); }
      // Pellets + Power-ups
      for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) if(MAP[y][x]===TILE_PELLET||MAP[y][x]===TILE_POWER){ const cx=x*TILE+TILE/2, cy=y*TILE+TILE/2; const isPower=MAP[y][x]===TILE_POWER; const r=isPower?6:3.2; const g=ctx.createRadialGradient(cx-1,cy-1,0,cx,cy,r); if(isPower){ g.addColorStop(0,'#ffe08a'); g.addColorStop(1,'#d6ac1d'); } else { g.addColorStop(0,'#8f0042'); g.addColorStop(1,'#5a0128'); } ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); if(!isPower){ ctx.fillStyle='#ffd666'; ctx.globalAlpha=0.7; ctx.fillRect(cx-0.8,cy-2.2,1.2,1.2); ctx.globalAlpha=1; } }
      // Entities
      drawCMU(state.player.x,state.player.y,state.player.radius*1.6);
      for(const g of state.enemies){ drawGhost(g.x,g.y,g.radius+4,g.color); }
    }

    // ===== Unified RAF loop =====
    function frame(){ step(); render(); requestAnimationFrame(frame); }

    // ===== Smoke tests =====
    (function tests(){
      console.assert(WIDTH===736 && HEIGHT===552,'Canvas size mismatch');
      console.assert(MAP.length===GRID_H,'Map row count');
      for(let y=0;y<MAP.length;y++) console.assert(MAP[y].length===GRID_W,'Row width');
      console.assert(MAP[playerStart.y][playerStart.x]!==TILE_WALL,'Player start not wall');
      console.assert(MAP[enemyStart.y][enemyStart.x]!==TILE_WALL,'Enemy start not wall');
      console.assert(Array.isArray(state.enemies)&&state.enemies.length===3,'Three ghosts seeded');
      console.assert(countPellets()>0,'Pellets exist');
      // Additional tests
      const before=JSON.stringify(MAP);
      randomizePowerPellets(4);
      console.assert(JSON.stringify(MAP)!==before,'Power pellet mutation occurred');
      loseLife();
      console.assert(state.enemies.length===3,'Ghosts respawn to 3 on death');
      console.assert(canMove(TILE*2,TILE*2,TILE*3,TILE*2,7), 'canMove should allow open step');
    })();

    // Init
    ui.pellets.textContent=state.pelletsLeft; ui.overlay.hidden=false;
    requestAnimationFrame(frame);
  </script>
</body>
</html>
